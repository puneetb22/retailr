"""
Sales UI for POS system
"""

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import datetime
import re
import os
import decimal
from decimal import Decimal, InvalidOperation

from assets.styles import COLORS, FONTS, STYLES
from utils.helpers import format_currency, parse_currency
from utils.invoice_generator import generate_invoice

class SalesFrame(tk.Frame):
    """Sales frame for processing transactions"""
    
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent, bg=COLORS["bg_primary"])
        self.controller = controller
        
        # Store cart items
        self.cart_items = []
        self.next_item_id = 1
        
        # Current customer
        self.current_customer = {
            "id": 1,  # Default to Walk-in Customer
            "name": "Walk-in Customer",
            "phone": "",
            "address": ""
        }
        
        # Create layout
        self.create_layout()
        
        # We now use the database for suspended bills
        # self.suspended_bills is kept for backward compatibility but not used
        
        # Keyboard navigation variables
        self.current_focus = None  # Current focus area: 'cart', 'products', 'buttons'
        self.selected_cart_item = -1
        self.selected_product_item = -1
        
        # Bind keyboard events
        self.bind("<Key>", self.handle_key_event)
        self.focus_set()
    
    def _set_dialog_transient(self, dialog):
        """Helper method to set dialog transient property correctly"""
        # Get the top-level window for this frame
        root = self.winfo_toplevel()
        dialog.transient(root)
        # Center dialog on parent
        x = self.winfo_x() + (self.winfo_width() // 2) - (dialog.winfo_width() // 2)
        y = self.winfo_y() + (self.winfo_height() // 2) - (dialog.winfo_height() // 2)
        dialog.geometry(f"+{x}+{y}")
    
    def create_layout(self):
        """Create the sales layout"""
        # Top customer search panel
        top_panel = tk.Frame(self, bg=COLORS["bg_primary"], padx=10, pady=8)
        top_panel.pack(fill=tk.X, padx=5, pady=(5, 0))
        
        # Customer search frame with dropdown, walk-in, new, and directory buttons
        self.setup_customer_search_panel(top_panel)
        
        # Main container with two frames side by side
        main_container = tk.Frame(self, bg=COLORS["bg_primary"])
        main_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Left panel - Cart (55% width)
        self.left_panel = tk.Frame(main_container, bg=COLORS["bg_primary"])
        self.left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Right panel - Product search and customer info (45% width)
        self.right_panel = tk.Frame(main_container, bg=COLORS["bg_secondary"], width=500)
        self.right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Make sure the right panel maintains width
        self.right_panel.grid_propagate(False)  # For grid layout
        self.right_panel.pack_propagate(False)  # For pack layout
        
        # Setup left panel (cart)
        self.setup_cart_panel(self.left_panel)
        
        # Setup right panel (product search)
        self.setup_product_panel(self.right_panel)
        
        # Add keyboard shortcuts info
        shortcut_frame = tk.Frame(self.right_panel, bg=COLORS["bg_secondary"], padx=10, pady=5)
        shortcut_frame.pack(fill=tk.X, side=tk.BOTTOM)
        
        shortcut_label = tk.Label(
            shortcut_frame,
            text="Keyboard Shortcuts: Tab: Cycle focus | Ctrl+Shift+P: Products | Ctrl+Shift+C: Cart | Enter: Add/Edit",
            font=FONTS["small"],
            bg=COLORS["bg_secondary"],
            fg=COLORS["text_secondary"],
            justify=tk.LEFT
        )
        shortcut_label.pack(anchor="w")
    def on_show(self):
        """Called when frame is shown"""
        # Reset the view
        self.load_products()
        
        # Load customers for dropdown
        self.load_customers_for_dropdown()
        
        # Set initial focus to products treeview
        self.current_focus = "products"
        
    def load_customers_for_dropdown(self):
        """Load customer list for dropdown"""
        db = self.controller.db
        query = """
            SELECT id, name, phone FROM customers
            ORDER BY name
            LIMIT 50
        """
        customers = db.fetchall(query)
        
        # Format customer list for combobox - no Walk-in customer by default
        customer_list = []
        self.customer_data = {}
        
        for i, customer in enumerate(customers):
            display_text = f"{customer[1]} ({customer[2] if customer[2] else 'No phone'})"
            customer_list.append(display_text)
            self.customer_data[i] = {"id": customer[0], "name": customer[1], "phone": customer[2] or ""}
        
        # Update combobox values
        self.customer_combo['values'] = customer_list
    
    def filter_customers(self, event):
        """Filter customers based on input in combobox"""
        search_term = self.customer_var.get().strip().lower()
        
        # Clear placeholder text if it exists
        if search_term == "search customers...":
            self.customer_combo.delete(0, tk.END)
            return
            
        # Skip searching if input is too short
        if len(search_term) < 2:
            return
        
        # Get all customers matching the search term
        db = self.controller.db
        query = """
            SELECT id, name, phone FROM customers
            WHERE LOWER(name) LIKE ? OR LOWER(phone) LIKE ?
            ORDER BY name
            LIMIT 50
        """
        
        # Use % for wildcard search
        search_pattern = f"%{search_term}%"
        customers = db.fetchall(query, (search_pattern, search_pattern))
        
        # Format customer list for combobox (no Walk-in Customer in dropdown)
        customer_list = []
        self.customer_data = {}
        
        for i, customer in enumerate(customers):
            display_text = f"{customer[1]} ({customer[2] if customer[2] else 'No phone'})"
            customer_list.append(display_text)
            self.customer_data[i] = {"id": customer[0], "name": customer[1], "phone": customer[2] or ""}
        
        # Update combobox values
        self.customer_combo['values'] = customer_list
        
        # If there are matching customers, show the dropdown
        if customer_list:
            self.customer_combo.event_generate('<Down>')
    
    def on_customer_selected(self, event):
        """Handle customer selection from dropdown"""
        selection = self.customer_combo.current()
        
        if selection >= 0 and selection in self.customer_data:
            customer_info = self.customer_data[selection]
            
            # Update current customer
            self.current_customer = {
                "id": customer_info["id"],
                "name": customer_info["name"],
                "phone": customer_info["phone"]
            }
            
            # Update customer label in cart panel
            self.customer_label.config(text=customer_info["name"])
    
    def set_walkin_customer(self):
        """Set customer to Walk-in Customer"""
        # Update combobox
        self.customer_var.set("Walk-in Customer")
        self.customer_combo.current(0)
        
        # Update current customer
        self.current_customer = {
            "id": 1,
            "name": "Walk-in Customer",
            "phone": ""
        }
        
        # Update customer label in cart panel
        self.customer_label.config(text="Walk-in Customer")
        self._update_focus()